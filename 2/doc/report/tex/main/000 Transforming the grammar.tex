
\section{Work on the Grammar}


\subsection{Making it $LL(1)$}
In order to make a grammar $LL(1)$ we had to apply some modifications on it. We had to remove left recursion, left-factor rules, remove unit productions.

\subsubsection{left recursion}

Top-down parsing is impossible on a left-recursive grammar. To solve this issue we replaced every left recursive rule by a right-recursive one.

the following rules have transformed into right-recursive: $LABELS$, $WORDS$, $EXPRESSION$.


\subsubsection{left-factoring rules}
Various productions can be left-factored if they have the form
$$A -> \alpha \beta_{1} | ... | \alpha\beta_{n}$$
with a common prefix $\alpha$.
whith
$$A -> \alpha A'$$
$$A' -> \beta_{1} | ... | \beta_{n}$$

For top-down parsers, rules must be left-factored.
It's for this reason that we modified the productions rules for
$CALL$, $VAR_DECL$, $WRITE$.


\subsubsection{Checking end of Program}

To be able to spot the en of the program we added a simple rule :
$$<S> -> <PROGRAM> EOF$$

\subsubsection{note}

As $LABEL$ and $END\_INST$ both resolve to a single terminal, we chose to remove them from the grammar and replace their occurences in the other rules by the only terminal they represent.

\subsubsection{Respect priority and associativity of operators}

The priority of operators must be defined by the grammar. We have divided the $EXPRESSION$ rule in different level \ref{expression}. This way an expression can be seen like a tree. The highest is the priority of an operator, the deepest it will be in the expression.\\ As the code is generated from the lef to the root we are sure priority of operators is respected.  



\subsubsection{Results}
\label{expression}
Here is the resulting grammar. The production rules that have been modified from the original grammar are shown in red:



\begin{lstlisting}[breaklines]
[ 0]       <ASSIGNATION> -> MOVE <EXPRESSION> TO IDENTIFIER END_OF_INSTRUCTION
[ 1]                     -> COMPUTE IDENTIFIER EQUALS_SIGN <EXPRESSION> END_OF_INSTRUCTION
[ 2]                     -> ADD <EXPRESSION> TO IDENTIFIER END_OF_INSTRUCTION
[ 3]                     -> SUBTRACT <EXPRESSION> FROM IDENTIFIER END_OF_INSTRUCTION
[ 4]                     -> MULTIPLY <ASSIGN_TAIL> END_OF_INSTRUCTION
[ 5]                     -> DIVIDE <ASSIGN_TAIL> END_OF_INSTRUCTION
[ 6]       <ASSIGN_TAIL> -> <EXPRESSION> COMMA <EXPRESSION> GIVING IDENTIFIER
[ 7]              <CALL> -> PERFORM IDENTIFIER <CALL_TAIL>
[ 8]         <CALL_TAIL> -> UNTIL <EXPRESSION> END_OF_INSTRUCTION
[ 9]                     -> END_OF_INSTRUCTION
[10]              <DATA> -> DATA DIVISION END_OF_INSTRUCTION WORKING_STORAGE SECTION END_OF_INSTRUCTION <VAR_LIST>
[11]               <ENV> -> ENVIRONMENT DIVISION END_OF_INSTRUCTION CONFIGURATION SECTION END_OF_INSTRUCTION SOURCE_COMPUTER DOT <WORDS> END_OF_INSTRUCTION OBJECT_COMPUTER DOT <WORDS> END_OF_INSTRUCTION
[12]        <EXPRESSION> -> <EXPRESSION_1> <EXPRESSION_TAIL> 
[13]      <EXPRESSION_1> -> <EXPRESSION_2> <EXPRESSION_1_TAIL>
[14] <EXPRESSION_1_TAIL> -> AND <EXPRESSION_2> <EXPRESSION_1_TAIL>
[15]                     -> ε
[16]      <EXPRESSION_2> -> <EXPRESSION_3> <EXPRESSION_2_TAIL>
[17] <EXPRESSION_2_TAIL> -> EQUALS_SIGN <EXPRESSION_3> <EXPRESSION_2_TAIL>
[18]                     -> LOWER_THAN <EXPRESSION_3> <EXPRESSION_2_TAIL>
[19]                     -> GREATER_THAN <EXPRESSION_3> <EXPRESSION_2_TAIL>
[20]                     -> LOWER_OR_EQUALS <EXPRESSION_3> <EXPRESSION_2_TAIL>
[21]                     -> GREATER_OR_EQUALS <EXPRESSION_3> <EXPRESSION_2_TAIL>
[22]                     -> ε
[23]      <EXPRESSION_3> -> <EXPRESSION_4> <EXPRESSION_3_TAIL>
[24] <EXPRESSION_3_TAIL> -> PLUS_SIGN <EXPRESSION_4> <EXPRESSION_3_TAIL>
[25]                     -> MINUS_SIGN <EXPRESSION_4> <EXPRESSION_3_TAIL>
[26]                     -> ε
[27]      <EXPRESSION_4> -> <EXPRESSION_BASE> <EXPRESSION_4_TAIL>
[28] <EXPRESSION_4_TAIL> -> ASTERISK <EXPRESSION_BASE> <EXPRESSION_4_TAIL>
[29]                     -> SLASH <EXPRESSION_BASE> <EXPRESSION_4_TAIL>
[30]                     -> ε
[31]   <EXPRESSION_BASE> -> LEFT_PARENTHESIS <EXPRESSION> RIGHT_PARENTHESIS
[32]                     -> NOT <EXPRESSION>
[33]                     -> MINUS_SIGN <EXPRESSION>
[34]                     -> IDENTIFIER
[35]                     -> INTEGER
[36]                     -> TRUE
[37]                     -> FALSE
[38]   <EXPRESSION_TAIL> -> OR <EXPRESSION_1> <EXPRESSION_TAIL>
[39]                     -> ε
[40]             <IDENT> -> IDENTIFICATION DIVISION END_OF_INSTRUCTION PROGRAM_ID DOT IDENTIFIER END_OF_INSTRUCTION AUTHOR DOT <WORDS> END_OF_INSTRUCTION DATE_WRITTEN DOT <WORDS> END_OF_INSTRUCTION
[41]                <IF> -> IF <EXPRESSION> THEN <INSTRUCTION_LIST> <IF_TAIL>
[42]           <IF_TAIL> -> ELSE <INSTRUCTION_LIST> END_IF
[43]                     -> END_IF
[44]       <INSTRUCTION> -> <ASSIGNATION>
[45]                     -> <IF>
[46]                     -> <CALL>
[47]                     -> <READ>
[48]                     -> <WRITE>
[49]                     -> STOP RUN END_OF_INSTRUCTION
[50]  <INSTRUCTION_LIST> -> <INSTRUCTION> <INSTRUCTION_LIST>
[51]                     -> ε
[52]            <LABELS> -> IDENTIFIER END_OF_INSTRUCTION <INSTRUCTION_LIST> <LABELS_TAIL>
[53]       <LABELS_TAIL> -> IDENTIFIER END_OF_INSTRUCTION <INSTRUCTION_LIST> <LABELS_TAIL>
[54]                     -> ε
[55]              <PROC> -> PROCEDURE DIVISION END_OF_INSTRUCTION IDENTIFIER SECTION END_OF_INSTRUCTION <LABELS> END PROGRAM IDENTIFIER DOT
[56]           <PROGRAM> -> <IDENT> <ENV> <DATA> <PROC>
[57]              <READ> -> ACCEPT IDENTIFIER END_OF_INSTRUCTION
[58]                 <S> -> <PROGRAM> EOF
[59]          <VAR_DECL> -> INTEGER IDENTIFIER PIC IMAGE <VAR_DECL_TAIL>
[60]     <VAR_DECL_TAIL> -> END_OF_INSTRUCTION
[61]                     -> VALUE INTEGER END_OF_INSTRUCTION
[62]          <VAR_LIST> -> <VAR_DECL> <VAR_LIST>
[63]                     -> ε
[64]             <WORDS> -> IDENTIFIER <WORDS>
[65]                     -> ε
[66]             <WRITE> -> DISPLAY <WRITE_TAIL>
[67]        <WRITE_TAIL> -> <EXPRESSION> END_OF_INSTRUCTION
[68]                     -> STRING END_OF_INSTRUCTION
\end{lstlisting}

\subsection{$First$, $Follows$, $Action table$}

We wrote python scripts implementing algorithms seen in class to generate the $first$, $follow$ sets and the $action table$.

