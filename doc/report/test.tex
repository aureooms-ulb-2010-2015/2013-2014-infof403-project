\documentclass[a4paper,12pt]{article}
\usepackage{perso}
\begin{document}
\titlepages[%
	author = {Chaste Gauvain, Ooms Aurélien},%
	course = INFO-F-403 : Introduction to Language Theory and Compilation,%
	COURSE = INFO-F-403,%
	title = Project 1 : S-COBOL,%
	bg = bg/ulb,%
	logo = logo/ulb,%
	faculty = Faculty of Science,%
	department = Computer Science Dept.,%
	university = Université Libre de Bruxelles,%
	academicyear = Academic year 2013~-~2014%
]
\begin{abstract}
\pagestyle{empty}

COBOL (\textbf{CO}mmon \textbf{B}usiness \textbf{O}riented \textbf{L}anguage) is a a project initiated by the United States
Department of Defense in order to simplify the implementation of management tools. The outcome of this
project was the definition of a rather verbose language popular between 1960 and
1980. This is why COBOL can be found, still today, as the software core of many big firms (e.g.
banks, insurances).

This is the first half of the compiler project. In this part of the project, we will
deal with the syntactical analysis part of the compiler, i.e., write the lexer that splits a piece of
S-COBOL into a sequence of tokens.

\end{abstract}

%\dedication{1}{2}{If you're happy and you know it, syntax error!}
\maketoc
\newpage\cleardoublepage\phantomsection
\section{Theory}
\subsection{Regular Expressions}

Here are shown the different special units belonging to the S-COBOL language under their regular expression (RE) form. For any keyword the RE is simply the keyword itself.

\subsubsection{Identifier}

\begin{verbatim}
[A-Za-z][0-9A-Za-z_\-]{0,15}
\end{verbatim}


\subsubsection{Image}

\begin{verbatim}
s?9(\([1-9][0-9]*\))?(v9(\([1-9][0-9]*\))?)?
\end{verbatim}


\subsubsection{Integer}

\begin{verbatim}
(\+|-)?(([1-9][0-9]*)|(0))
\end{verbatim}


\subsubsection{Real}

\begin{verbatim}
(integer)(\.[0-9]+)
\end{verbatim}


\subsubsection{String}

\begin{verbatim}
'[0-9A-Za-z\+\-\*/:!\? ]*'
\end{verbatim}


\subsubsection{Comment}

\begin{verbatim}
(\*|/).*\.\n;
\end{verbatim}
\subsection{Finite Automaton}
A simulator of the deterministic finite automaton (DFA) implemented for this assignment can be found in the dfa  folder of our work. This DFA recognizes only two S-COBOL keywords. The mechanism used to recognize the rest of the keywords can easily be deducted from those two examples.
\newpage\cleardoublepage\phantomsection
\section{Implementation}
\subsection{Choices}

In order to maintain efficiency or to avoid ambiguity we have added a certain number of constraints on the S-COBOL language. Here is the exhaustive list of our arbitrary choices and the reasons why we have made them.

\subsubsection{Signed numbers vs arithmetic expressions}

To avoid ambiguity an arithmetic expression will only be considered as one if a space is present between the operator and the operand. If no space can be found between the two, the token will be taken as an integer or a real.

\subsubsection{Comments}
\label{sec:impl:choices:comments}

Comments have to be on their own line (only space and tab characters are allowed). This way the / and * characters will not be seen as operators.

The RE for comments becomes:

\begin{verbatim}
^[ \t]*(\*|/).*\.\n;
\end{verbatim}

\subsubsection{Images vs Identifier}

We chose to make the parentheses in an image mandatory. This constraint can be made without loss of generality and ensure a more intuitive system:

\begin{itemize}
	\item Token 9 can be interpreted as an integer and is no longer cause of ambiguity.
	\item Tokens s9 and s9v9 can be used as identifiers while image representations s9(1) and s9(1)v9(1) still exist.  
\end{itemize}

Then the RE for Images becomes:

\begin{verbatim}
s?9(\([1-9][0-9]*\))(v9(\([1-9][0-9]*\)))?
\end{verbatim}

\subsubsection{ASCII only}

Our program will only recognise ASCII characters but could easily be extended to utf-8 charset.

\subsubsection{Keywords in lower case}

To ensure harmony our program will only accept lower case keywords. This allows the use of keywords as identifiers just by capitalizing one letter at least.







\subsection{Lexer}
We have implemented our lexical analyser in two different ways. One is Regex based, using compiled java patterns and the other is the direct implementation of the DFA recognizing S-COBOL.
\subsubsection{Regex}

The first implementation uses one big RE which is the product of the disjunction of all lexical units RE.

\begin{verbatim}
(A)|(B)|(C)|...
\end{verbatim}

The order in which they are concatenated is chosen to make sure no ambiguity is possible.




\subsubsection{DFA}

A state is a class composed of a \textit{token} (the read input so far) and one function \textit{next}. This method is the transition function, it takes as parameters a character and another state.

A state can be final, each of the final states are bounded to a syntactical unit, a meaningful token in S-COBOL. The other ones are non-final and correspond to the rejecting states of the DFA.
The DFA is then a map filled with all the states created.

The keywords and identifiers states have been automatically generated by a custom python script to avoid repetitive work.

In order to detect comments as they were defined in \ref{sec:impl:choices:comments}, we had to implement two DFA's : one for the tokens standing alone on a line and the second for all the other tokens. The detail of the implementation can be looked at in the \href{../more/src/cs/lang/LexicalAnalyzer3.java}{LexicalAnalyzer3 class}.
\subsection{Parser}

The parser we implemented finds the variables and labels. To find the variables the parser detects the \textit{data division}, variables are then all identifiers followed by images. The labels are all identifiers found in the \textit{procedure division} that are not in the variable table.


\newpage\cleardoublepage\phantomsection
\section{Use Cases}
\subsection{Regular usage}


stdin prompt

\shellcmd{java -jar dist/s\_cobol\_lexical\_analysis.jar}

stdin pipe

\shellcmd{cat test/in/1 | java -jar dist/s\_cobol\_lexical\_analysis.jar}


file stream

\shellcmd{java -jar dist/s\_cobol\_lexical\_analysis.jar test/in/1}
\subsection{-{}-mode option}

-{}-mode is one of [class, regex, map]. The default one is \emph{class}.
\emph{map} is far from complete.

\shellcmd{java -jar dist/s\_cobol\_lexical\_analysis.jar -{}-mode class|regex|map}
\subsection{-{}-comment flag}

If the -{}-comment flag is set the lexer doesn't discard comments.

\shellcmd{java -jar dist/s\_cobol\_lexical\_analysis.jar -{}-comment}
\subsection{Run tests}

In order to run tests \emph{bash} must be installed.

\shellcmd{python3 test/run}
\appendix
%\section{My appendix}
%\makebib{bib/1}
%\makefig
%\makeequ
%\makeminted
%\makethm
%\makealg
%\makeind
\end{document}
